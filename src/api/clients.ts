/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.4.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    login(command: LoginCommand , cancelToken?: CancelToken | undefined): Promise<LoginReply> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<LoginReply> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginReply.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginReply>(<any>null);
    }
}

export class ArchitectsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<ArchitectDto[]> {
        let url_ = this.baseUrl + "/api/catalog/architects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ArchitectDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArchitectDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArchitectDto[]>(<any>null);
    }

    save(state: ArchitectStateDto , cancelToken?: CancelToken | undefined): Promise<ArchitectStateDto> {
        let url_ = this.baseUrl + "/api/catalog/architects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<ArchitectStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ArchitectStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArchitectStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<ArchitectStateDto> {
        let url_ = this.baseUrl + "/api/catalog/architects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ArchitectStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ArchitectStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArchitectStateDto>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/architects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getUsers(id: number , cancelToken?: CancelToken | undefined): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/api/catalog/architects/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: AxiosResponse): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto[]>(<any>null);
    }

    batchSave(state: ArchitectStateDto[] , cancelToken?: CancelToken | undefined): Promise<ArchitectStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/architects/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<ArchitectStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArchitectStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArchitectStateDto[]>(<any>null);
    }
}

export class AreasClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<AreaDto[]> {
        let url_ = this.baseUrl + "/api/geo/areas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<AreaDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AreaDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AreaDto[]>(<any>null);
    }

    save(state: AreaStateDto , cancelToken?: CancelToken | undefined): Promise<AreaStateDto> {
        let url_ = this.baseUrl + "/api/geo/areas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<AreaStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AreaStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AreaStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<AreaStateDto> {
        let url_ = this.baseUrl + "/api/geo/areas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<AreaStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AreaStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AreaStateDto>(<any>null);
    }

    batchSave(state: AreaStateDto[] , cancelToken?: CancelToken | undefined): Promise<AreaStateDto[]> {
        let url_ = this.baseUrl + "/api/geo/areas/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<AreaStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AreaStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AreaStateDto[]>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/geo/areas/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/geo/areas/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class BundlesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(projectTypeId: number | undefined , cancelToken?: CancelToken | undefined): Promise<BundleDto[]> {
        let url_ = this.baseUrl + "/api/catalog/bundles?";
        if (projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' cannot be null.");
        else if (projectTypeId !== undefined)
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<BundleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BundleDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BundleDto[]>(<any>null);
    }

    save(state: BundleStateDto , cancelToken?: CancelToken | undefined): Promise<BundleStateDto> {
        let url_ = this.baseUrl + "/api/catalog/bundles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<BundleStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BundleStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BundleStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<BundleStateDto> {
        let url_ = this.baseUrl + "/api/catalog/bundles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<BundleStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BundleStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BundleStateDto>(<any>null);
    }

    batchSave(state: BundleStateDto[] , cancelToken?: CancelToken | undefined): Promise<BundleStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/bundles/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<BundleStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BundleStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BundleStateDto[]>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<BundleStateDto> {
        let url_ = this.baseUrl + "/api/catalog/bundles/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<BundleStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BundleStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BundleStateDto>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/bundles/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class CategoriesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getSchemas(  cancelToken?: CancelToken | undefined): Promise<CategorySchemaDto[]> {
        let url_ = this.baseUrl + "/api/catalog/schemas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchemas(_response);
        });
    }

    protected processGetSchemas(response: AxiosResponse): Promise<CategorySchemaDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySchemaDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaDto[]>(<any>null);
    }

    createSchema(command: CreateCategorySchemaCommandDto , cancelToken?: CancelToken | undefined): Promise<CategorySchemaDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSchema(_response);
        });
    }

    protected processCreateSchema(response: AxiosResponse): Promise<CategorySchemaDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaDto>(<any>null);
    }

    saveSchema(command: CategorySchemaStateDto , cancelToken?: CancelToken | undefined): Promise<CategorySchemaStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveSchema(_response);
        });
    }

    protected processSaveSchema(response: AxiosResponse): Promise<CategorySchemaStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaStateDto>(<any>null);
    }

    getSchema(id: number , cancelToken?: CancelToken | undefined): Promise<CategorySchemaStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchema(_response);
        });
    }

    protected processGetSchema(response: AxiosResponse): Promise<CategorySchemaStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaStateDto>(<any>null);
    }

    publishSchema(command: PublishCategorySchemaCommandDto , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/schemas/publish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublishSchema(_response);
        });
    }

    protected processPublishSchema(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    deleteSchema(schemaId: number , cancelToken?: CancelToken | undefined): Promise<CategorySchemaDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteSchema(_response);
        });
    }

    protected processDeleteSchema(response: AxiosResponse): Promise<CategorySchemaDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaDto>(<any>null);
    }

    getTemplates(schemaId: number , cancelToken?: CancelToken | undefined): Promise<ValueTupleOfStringAndString[]> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/templates";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTemplates(_response);
        });
    }

    protected processGetTemplates(response: AxiosResponse): Promise<ValueTupleOfStringAndString[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ValueTupleOfStringAndString.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ValueTupleOfStringAndString[]>(<any>null);
    }

    getProjectTypes(schemaId: number , cancelToken?: CancelToken | undefined): Promise<CategorySchemaProjectTypeDto[]> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/project-types";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProjectTypes(_response);
        });
    }

    protected processGetProjectTypes(response: AxiosResponse): Promise<CategorySchemaProjectTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySchemaProjectTypeDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaProjectTypeDto[]>(<any>null);
    }

    saveProjectType(schemaId: number, state: CategorySchemaProjectTypeStateDto , cancelToken?: CancelToken | undefined): Promise<CategorySchemaProjectTypeStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/project-types";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveProjectType(_response);
        });
    }

    protected processSaveProjectType(response: AxiosResponse): Promise<CategorySchemaProjectTypeStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaProjectTypeStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaProjectTypeStateDto>(<any>null);
    }

    deleteProjectType(schemaId: number, id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/project-types/{id}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteProjectType(_response);
        });
    }

    protected processDeleteProjectType(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getCities(schemaId: number , cancelToken?: CancelToken | undefined): Promise<CategorySchemaCityDto[]> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/cities";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCities(_response);
        });
    }

    protected processGetCities(response: AxiosResponse): Promise<CategorySchemaCityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySchemaCityDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaCityDto[]>(<any>null);
    }

    saveCity(schemaId: number, state: CategorySchemaCityStateDto , cancelToken?: CancelToken | undefined): Promise<CategorySchemaCityStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/cities";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveCity(_response);
        });
    }

    protected processSaveCity(response: AxiosResponse): Promise<CategorySchemaCityStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaCityStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaCityStateDto>(<any>null);
    }

    deleteCity(schemaId: number, id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/cities/{id}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteCity(_response);
        });
    }

    protected processDeleteCity(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getGroups(schemaId: number, projectTypeId: number | null | undefined , cancelToken?: CancelToken | undefined): Promise<CategorySchemaGroupDto[]> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/groups?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (projectTypeId !== undefined && projectTypeId !== null)
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGroups(_response);
        });
    }

    protected processGetGroups(response: AxiosResponse): Promise<CategorySchemaGroupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySchemaGroupDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaGroupDto[]>(<any>null);
    }

    saveGroup(schemaId: number, state: CategorySchemaGroupStateDto , cancelToken?: CancelToken | undefined): Promise<CategorySchemaGroupStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/groups";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveGroup(_response);
        });
    }

    protected processSaveGroup(response: AxiosResponse): Promise<CategorySchemaGroupStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaGroupStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaGroupStateDto>(<any>null);
    }

    deleteGroup(schemaId: number, id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/groups/{id}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteGroup(_response);
        });
    }

    protected processDeleteGroup(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getUiGroups(schemaId: number, projectTypeId: number | null | undefined , cancelToken?: CancelToken | undefined): Promise<CategorySchemaUiGroupDto[]> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/ui-groups?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (projectTypeId !== undefined && projectTypeId !== null)
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUiGroups(_response);
        });
    }

    protected processGetUiGroups(response: AxiosResponse): Promise<CategorySchemaUiGroupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySchemaUiGroupDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaUiGroupDto[]>(<any>null);
    }

    saveUiGroup(schemaId: number, state: CategorySchemaUiGroupStateDto , cancelToken?: CancelToken | undefined): Promise<CategorySchemaUiGroupStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/ui-groups";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveUiGroup(_response);
        });
    }

    protected processSaveUiGroup(response: AxiosResponse): Promise<CategorySchemaUiGroupStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaUiGroupStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaUiGroupStateDto>(<any>null);
    }

    deleteUiGroup(schemaId: number, id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/ui-groups/{id}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUiGroup(_response);
        });
    }

    protected processDeleteUiGroup(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getElements(schemaId: number, projectTypeId: number | undefined , cancelToken?: CancelToken | undefined): Promise<CategorySchemaElementDto[]> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/elements?";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' cannot be null.");
        else if (projectTypeId !== undefined)
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetElements(_response);
        });
    }

    protected processGetElements(response: AxiosResponse): Promise<CategorySchemaElementDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySchemaElementDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaElementDto[]>(<any>null);
    }

    saveElement(schemaId: number, state: CategorySchemaElementStateDto , cancelToken?: CancelToken | undefined): Promise<CategorySchemaElementStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/elements";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveElement(_response);
        });
    }

    protected processSaveElement(response: AxiosResponse): Promise<CategorySchemaElementStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaElementStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaElementStateDto>(<any>null);
    }

    getElementById(schemaId: number, id: number , cancelToken?: CancelToken | undefined): Promise<CategorySchemaElementStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/elements/{id}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetElementById(_response);
        });
    }

    protected processGetElementById(response: AxiosResponse): Promise<CategorySchemaElementStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaElementStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaElementStateDto>(<any>null);
    }

    deleteElement(schemaId: number, id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/elements/{id}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteElement(_response);
        });
    }

    protected processDeleteElement(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getContent(schemaId: number , cancelToken?: CancelToken | undefined): Promise<CategorySchemaContentDto[]> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/content";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetContent(_response);
        });
    }

    protected processGetContent(response: AxiosResponse): Promise<CategorySchemaContentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySchemaContentDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaContentDto[]>(<any>null);
    }

    saveContent(schemaId: number, state: CategorySchemaContentStateDto , cancelToken?: CancelToken | undefined): Promise<CategorySchemaContentStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/content";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveContent(_response);
        });
    }

    protected processSaveContent(response: AxiosResponse): Promise<CategorySchemaContentStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaContentStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaContentStateDto>(<any>null);
    }

    getContentById(schemaId: number, id: number , cancelToken?: CancelToken | undefined): Promise<CategorySchemaContentStateDto> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/content/{id}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetContentById(_response);
        });
    }

    protected processGetContentById(response: AxiosResponse): Promise<CategorySchemaContentStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategorySchemaContentStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategorySchemaContentStateDto>(<any>null);
    }

    deleteContent(schemaId: number, id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/schemas/{schemaId}/content/{id}";
        if (schemaId === undefined || schemaId === null)
            throw new Error("The parameter 'schemaId' must be defined.");
        url_ = url_.replace("{schemaId}", encodeURIComponent("" + schemaId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteContent(_response);
        });
    }

    protected processDeleteContent(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class CitiesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(regionId: number | null | undefined , cancelToken?: CancelToken | undefined): Promise<CityDto[]> {
        let url_ = this.baseUrl + "/api/geo/cities?";
        if (regionId !== undefined && regionId !== null)
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<CityDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDto[]>(<any>null);
    }

    save(state: CityStateDto , cancelToken?: CancelToken | undefined): Promise<CityStateDto> {
        let url_ = this.baseUrl + "/api/geo/cities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<CityStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CityStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<CityStateDto> {
        let url_ = this.baseUrl + "/api/geo/cities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<CityStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CityStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityStateDto>(<any>null);
    }

    batchSave(state: CityStateDto[] , cancelToken?: CancelToken | undefined): Promise<CityStateDto[]> {
        let url_ = this.baseUrl + "/api/geo/cities/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<CityStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityStateDto[]>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<CityStateDto> {
        let url_ = this.baseUrl + "/api/geo/cities/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<CityStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CityStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityStateDto>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/geo/cities/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class CollectionsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<CollectionDto[]> {
        let url_ = this.baseUrl + "/api/catalog/collections";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<CollectionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CollectionDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CollectionDto[]>(<any>null);
    }

    save(state: CollectionStateDto , cancelToken?: CancelToken | undefined): Promise<CollectionStateDto> {
        let url_ = this.baseUrl + "/api/catalog/collections";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<CollectionStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CollectionStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CollectionStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<CollectionStateDto> {
        let url_ = this.baseUrl + "/api/catalog/collections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<CollectionStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CollectionStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CollectionStateDto>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/collections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    batchSave(state: CollectionStateDto[] , cancelToken?: CancelToken | undefined): Promise<CollectionStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/collections/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<CollectionStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CollectionStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CollectionStateDto[]>(<any>null);
    }
}

export class ContentCategoriesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    search(parentId: number | null | undefined, name: string | null | undefined, dateFrom: Date | null | undefined, dateTo: Date | null | undefined, states: ContentCategoryState[] | null | undefined, pageNo: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/content/categories?";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (dateFrom !== undefined && dateFrom !== null)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&";
        if (dateTo !== undefined && dateTo !== null)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&";
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (pageNo === null)
            throw new Error("The parameter 'pageNo' cannot be null.");
        else if (pageNo !== undefined)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<PagedResultOfCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfCategoryDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfCategoryDto>(<any>null);
    }

    save(state: CategoryStateDto , cancelToken?: CancelToken | undefined): Promise<CategoryStateDto> {
        let url_ = this.baseUrl + "/api/content/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<CategoryStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryStateDto>(<any>null);
    }

    getById(id: number , cancelToken?: CancelToken | undefined): Promise<CategoryStateDto> {
        let url_ = this.baseUrl + "/api/content/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<CategoryStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryStateDto>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<CategoryStateDto> {
        let url_ = this.baseUrl + "/api/content/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<CategoryStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryStateDto>(<any>null);
    }

    override(id: number, state: CategoryOverrideCommand , cancelToken?: CancelToken | undefined): Promise<CategoryStateDto> {
        let url_ = this.baseUrl + "/api/content/categories/{id}/override";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOverride(_response);
        });
    }

    protected processOverride(response: AxiosResponse): Promise<CategoryStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryStateDto>(<any>null);
    }

    publish(id: number, options: PublishCategoryOptions , cancelToken?: CancelToken | undefined): Promise<CategoryStateDto> {
        let url_ = this.baseUrl + "/api/content/categories/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<CategoryStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryStateDto>(<any>null);
    }

    publishBatch(options: { [key: string]: PublishCategoryOptions; } , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/content/categories/publish/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublishBatch(_response);
        });
    }

    protected processPublishBatch(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class ContentPostsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    search(categoryId: number | null | undefined, name: string | null | undefined, tag: string | null | undefined, dateFrom: Date | null | undefined, dateTo: Date | null | undefined, states: ContentPostState[] | null | undefined, pageNo: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfPostDto> {
        let url_ = this.baseUrl + "/api/content/posts?";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (tag !== undefined && tag !== null)
            url_ += "Tag=" + encodeURIComponent("" + tag) + "&";
        if (dateFrom !== undefined && dateFrom !== null)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&";
        if (dateTo !== undefined && dateTo !== null)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&";
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (pageNo === null)
            throw new Error("The parameter 'pageNo' cannot be null.");
        else if (pageNo !== undefined)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<PagedResultOfPostDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfPostDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfPostDto>(<any>null);
    }

    save(state: PostStateDto , cancelToken?: CancelToken | undefined): Promise<PostStateDto> {
        let url_ = this.baseUrl + "/api/content/posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<PostStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostStateDto>(<any>null);
    }

    getById(id: number , cancelToken?: CancelToken | undefined): Promise<PostStateDto> {
        let url_ = this.baseUrl + "/api/content/posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<PostStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostStateDto>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<PostStateDto> {
        let url_ = this.baseUrl + "/api/content/posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<PostStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostStateDto>(<any>null);
    }

    override(id: number, state: PostOverrideCommand , cancelToken?: CancelToken | undefined): Promise<PostStateDto> {
        let url_ = this.baseUrl + "/api/content/posts/{id}/override";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOverride(_response);
        });
    }

    protected processOverride(response: AxiosResponse): Promise<PostStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostStateDto>(<any>null);
    }

    publish(id: number, options: PublishPostOptions , cancelToken?: CancelToken | undefined): Promise<PostStateDto> {
        let url_ = this.baseUrl + "/api/content/posts/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<PostStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostStateDto>(<any>null);
    }

    publishBatch(options: { [key: string]: PublishPostOptions; } , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/content/posts/publish/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublishBatch(_response);
        });
    }

    protected processPublishBatch(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class ContentTagsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    search(name: string | null | undefined, dateFrom: Date | null | undefined, dateTo: Date | null | undefined, states: ContentTagState[] | null | undefined, pageNo: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfTagDto> {
        let url_ = this.baseUrl + "/api/content/tags?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (dateFrom !== undefined && dateFrom !== null)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&";
        if (dateTo !== undefined && dateTo !== null)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&";
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (pageNo === null)
            throw new Error("The parameter 'pageNo' cannot be null.");
        else if (pageNo !== undefined)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<PagedResultOfTagDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfTagDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfTagDto>(<any>null);
    }

    save(state: TagStateDto , cancelToken?: CancelToken | undefined): Promise<TagStateDto> {
        let url_ = this.baseUrl + "/api/content/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<TagStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TagStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagStateDto>(<any>null);
    }

    getById(id: number , cancelToken?: CancelToken | undefined): Promise<TagStateDto> {
        let url_ = this.baseUrl + "/api/content/tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<TagStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TagStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagStateDto>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<TagStateDto> {
        let url_ = this.baseUrl + "/api/content/tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<TagStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TagStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagStateDto>(<any>null);
    }

    publish(id: number, options: PublishTagOptions , cancelToken?: CancelToken | undefined): Promise<TagStateDto> {
        let url_ = this.baseUrl + "/api/content/tags/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<TagStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TagStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagStateDto>(<any>null);
    }

    publishBatch(options: { [key: string]: PublishTagOptions; } , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/content/tags/publish/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublishBatch(_response);
        });
    }

    protected processPublishBatch(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class FilesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    /**
     * @param folder (optional) 
     * @param file file
     */
    upload(folder: string | null | undefined, file: FileParameter , cancelToken?: CancelToken | undefined): Promise<ImageDto[]> {
        let url_ = this.baseUrl + "/api/files?";
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: AxiosResponse): Promise<ImageDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImageDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImageDto[]>(<any>null);
    }
}

export class MaterialsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(groupId: number | null | undefined , cancelToken?: CancelToken | undefined): Promise<MaterialDto[]> {
        let url_ = this.baseUrl + "/api/catalog/materials?";
        if (groupId !== undefined && groupId !== null)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MaterialDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaterialDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialDto[]>(<any>null);
    }

    save(state: MaterialStateDto , cancelToken?: CancelToken | undefined): Promise<MaterialStateDto> {
        let url_ = this.baseUrl + "/api/catalog/materials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<MaterialStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MaterialStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<MaterialStateDto> {
        let url_ = this.baseUrl + "/api/catalog/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<MaterialStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MaterialStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialStateDto>(<any>null);
    }

    batchSave(state: MaterialStateDto[] , cancelToken?: CancelToken | undefined): Promise<MaterialStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/materials/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<MaterialStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaterialStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialStateDto[]>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<MaterialStateDto> {
        let url_ = this.baseUrl + "/api/catalog/materials/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<MaterialStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MaterialStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialStateDto>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/catalog/materials/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class MaterialGroupsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<MaterialGroupDto[]> {
        let url_ = this.baseUrl + "/api/catalog/material-groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MaterialGroupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaterialGroupDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialGroupDto[]>(<any>null);
    }

    save(state: MaterialGroupStateDto , cancelToken?: CancelToken | undefined): Promise<MaterialGroupStateDto> {
        let url_ = this.baseUrl + "/api/catalog/material-groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<MaterialGroupStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MaterialGroupStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialGroupStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<MaterialGroupStateDto> {
        let url_ = this.baseUrl + "/api/catalog/material-groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<MaterialGroupStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MaterialGroupStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialGroupStateDto>(<any>null);
    }

    batchSave(state: MaterialGroupStateDto[] , cancelToken?: CancelToken | undefined): Promise<MaterialGroupStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/material-groups/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<MaterialGroupStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaterialGroupStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialGroupStateDto[]>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<MaterialGroupStateDto> {
        let url_ = this.baseUrl + "/api/catalog/material-groups/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<MaterialGroupStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MaterialGroupStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MaterialGroupStateDto>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/catalog/material-groups/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class ModelClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getPropertyTypes(  cancelToken?: CancelToken | undefined): Promise<PropertyTypeDto[]> {
        let url_ = this.baseUrl + "/api/catalog/models/property-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPropertyTypes(_response);
        });
    }

    protected processGetPropertyTypes(response: AxiosResponse): Promise<PropertyTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyTypeDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyTypeDto[]>(<any>null);
    }
}

export class OptionGroupsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(projectTypeId: number | undefined , cancelToken?: CancelToken | undefined): Promise<OptionGroupDto[]> {
        let url_ = this.baseUrl + "/api/catalog/option-groups?";
        if (projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' cannot be null.");
        else if (projectTypeId !== undefined)
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<OptionGroupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionGroupDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionGroupDto[]>(<any>null);
    }

    save(state: OptionGroupStateDto , cancelToken?: CancelToken | undefined): Promise<OptionGroupStateDto> {
        let url_ = this.baseUrl + "/api/catalog/option-groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<OptionGroupStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OptionGroupStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionGroupStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<OptionGroupStateDto> {
        let url_ = this.baseUrl + "/api/catalog/option-groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OptionGroupStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OptionGroupStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionGroupStateDto>(<any>null);
    }

    batchSave(state: OptionGroupStateDto[] , cancelToken?: CancelToken | undefined): Promise<OptionGroupStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/option-groups/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<OptionGroupStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionGroupStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionGroupStateDto[]>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<OptionGroupStateDto> {
        let url_ = this.baseUrl + "/api/catalog/option-groups/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<OptionGroupStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OptionGroupStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionGroupStateDto>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/option-groups/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class OptionsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(projectTypeId: number | undefined , cancelToken?: CancelToken | undefined): Promise<OptionDto[]> {
        let url_ = this.baseUrl + "/api/catalog/options?";
        if (projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' cannot be null.");
        else if (projectTypeId !== undefined)
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<OptionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionDto[]>(<any>null);
    }

    save(state: OptionStateDto , cancelToken?: CancelToken | undefined): Promise<OptionStateDto> {
        let url_ = this.baseUrl + "/api/catalog/options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<OptionStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OptionStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<OptionStateDto> {
        let url_ = this.baseUrl + "/api/catalog/options/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OptionStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OptionStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionStateDto>(<any>null);
    }

    batchSave(state: OptionStateDto[] , cancelToken?: CancelToken | undefined): Promise<OptionStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/options/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<OptionStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionStateDto[]>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<OptionStateDto> {
        let url_ = this.baseUrl + "/api/catalog/options/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<OptionStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OptionStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OptionStateDto>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/options/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class PagesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    search(parentId: number | null | undefined, name: string | null | undefined, dateFrom: Date | null | undefined, dateTo: Date | null | undefined, states: PageState[] | null | undefined, pageNo: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfPageDto> {
        let url_ = this.baseUrl + "/api/site/pages?";
        if (parentId !== undefined && parentId !== null)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (dateFrom !== undefined && dateFrom !== null)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&";
        if (dateTo !== undefined && dateTo !== null)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&";
        if (states !== undefined && states !== null)
            states && states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (pageNo === null)
            throw new Error("The parameter 'pageNo' cannot be null.");
        else if (pageNo !== undefined)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<PagedResultOfPageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfPageDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfPageDto>(<any>null);
    }

    save(state: PageStateDto , cancelToken?: CancelToken | undefined): Promise<PageStateDto> {
        let url_ = this.baseUrl + "/api/site/pages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<PageStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageStateDto>(<any>null);
    }

    getById(id: number , cancelToken?: CancelToken | undefined): Promise<PageStateDto> {
        let url_ = this.baseUrl + "/api/site/pages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<PageStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageStateDto>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<PageStateDto> {
        let url_ = this.baseUrl + "/api/site/pages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<PageStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageStateDto>(<any>null);
    }

    override(id: number, state: PageOverrideCommand , cancelToken?: CancelToken | undefined): Promise<PageStateDto> {
        let url_ = this.baseUrl + "/api/site/pages/{id}/override";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOverride(_response);
        });
    }

    protected processOverride(response: AxiosResponse): Promise<PageStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageStateDto>(<any>null);
    }

    publish(id: number, options: PublishPageOptions , cancelToken?: CancelToken | undefined): Promise<PageStateDto> {
        let url_ = this.baseUrl + "/api/site/pages/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<PageStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageStateDto>(<any>null);
    }

    publishBatch(options: { [key: string]: PublishPageOptions; } , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/site/pages/publish/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublishBatch(_response);
        });
    }

    protected processPublishBatch(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }
}

export class PriceListClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<PriceListDto[]> {
        let url_ = this.baseUrl + "/api/catalog/price-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PriceListDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PriceListDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PriceListDto[]>(<any>null);
    }

    create(priceListId: number | null | undefined , cancelToken?: CancelToken | undefined): Promise<PriceListDto> {
        let url_ = this.baseUrl + "/api/catalog/price-list?";
        if (priceListId !== undefined && priceListId !== null)
            url_ += "priceListId=" + encodeURIComponent("" + priceListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<PriceListDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PriceListDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PriceListDto>(<any>null);
    }

    publish(priceListId: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/price-list/{priceListId}";
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    delete(priceListId: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/price-list/{priceListId}";
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getRules(priceListId: number, projectTypeId: number | null | undefined , cancelToken?: CancelToken | undefined): Promise<PriceRuleStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/price-list/{priceListId}/rules?";
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        if (projectTypeId !== undefined && projectTypeId !== null)
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRules(_response);
        });
    }

    protected processGetRules(response: AxiosResponse): Promise<PriceRuleStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PriceRuleStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PriceRuleStateDto[]>(<any>null);
    }

    saveRule(priceListId: number, state: PriceRuleStateDto , cancelToken?: CancelToken | undefined): Promise<PriceRuleStateDto> {
        let url_ = this.baseUrl + "/api/catalog/price-list/{priceListId}/rules";
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveRule(_response);
        });
    }

    protected processSaveRule(response: AxiosResponse): Promise<PriceRuleStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PriceRuleStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PriceRuleStateDto>(<any>null);
    }

    deleteRule(id: number, priceListId: string , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/price-list/{priceListId}/rules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteRule(_response);
        });
    }

    protected processDeleteRule(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class ProjectsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    search(projectTypeId: number | undefined, architectId: number | null | undefined, sku: string | null | undefined, from: Date | null | undefined, to: Date | null | undefined, state: ProjectState[] | null | undefined, collections: number[] | null | undefined, order: string | null | undefined, specification: string | null | undefined, pageNo: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfProjectDto> {
        let url_ = this.baseUrl + "/api/catalog/projects?";
        if (projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' cannot be null.");
        else if (projectTypeId !== undefined)
            url_ += "ProjectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        if (architectId !== undefined && architectId !== null)
            url_ += "ArchitectId=" + encodeURIComponent("" + architectId) + "&";
        if (sku !== undefined && sku !== null)
            url_ += "Sku=" + encodeURIComponent("" + sku) + "&";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&";
        if (state !== undefined && state !== null)
            state && state.forEach(item => { url_ += "State=" + encodeURIComponent("" + item) + "&"; });
        if (collections !== undefined && collections !== null)
            collections && collections.forEach(item => { url_ += "Collections=" + encodeURIComponent("" + item) + "&"; });
        if (order !== undefined && order !== null)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (specification !== undefined && specification !== null)
            url_ += "Specification=" + encodeURIComponent("" + specification) + "&";
        if (pageNo === null)
            throw new Error("The parameter 'pageNo' cannot be null.");
        else if (pageNo !== undefined)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<PagedResultOfProjectDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfProjectDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfProjectDto>(<any>null);
    }

    create(command: CreateProjectCommandDto , cancelToken?: CancelToken | undefined): Promise<ProjectStateDto> {
        let url_ = this.baseUrl + "/api/catalog/projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ProjectStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectStateDto>(<any>null);
    }

    update(state: ProjectStateDto , cancelToken?: CancelToken | undefined): Promise<ProjectStateDto> {
        let url_ = this.baseUrl + "/api/catalog/projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<ProjectStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectStateDto>(<any>null);
    }

    searchByAttributes(projectTypeId: number | undefined, type: SpecificationStateType | undefined, property: string | null | undefined, operator: string | null | undefined, value: string | null | undefined, specifications: SpecificationState[] | null | undefined, page: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfProjectDto> {
        let url_ = this.baseUrl + "/api/catalog/projects/byAttributes?";
        if (projectTypeId === null)
            throw new Error("The parameter 'projectTypeId' cannot be null.");
        else if (projectTypeId !== undefined)
            url_ += "projectTypeId=" + encodeURIComponent("" + projectTypeId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (property !== undefined && property !== null)
            url_ += "Property=" + encodeURIComponent("" + property) + "&";
        if (operator !== undefined && operator !== null)
            url_ += "Operator=" + encodeURIComponent("" + operator) + "&";
        if (value !== undefined && value !== null)
            url_ += "Value=" + encodeURIComponent("" + value) + "&";
        if (specifications !== undefined && specifications !== null)
            specifications && specifications.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Specifications[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchByAttributes(_response);
        });
    }

    protected processSearchByAttributes(response: AxiosResponse): Promise<PagedResultOfProjectDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfProjectDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfProjectDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<ProjectStateDto> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProjectStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectStateDto>(<any>null);
    }

    getAnalogs(id: number , cancelToken?: CancelToken | undefined): Promise<ProjectAnalogDto[]> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}/analogs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAnalogs(_response);
        });
    }

    protected processGetAnalogs(response: AxiosResponse): Promise<ProjectAnalogDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectAnalogDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectAnalogDto[]>(<any>null);
    }

    getBundles(id: number , cancelToken?: CancelToken | undefined): Promise<ProjectBundleDto[]> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}/bundles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBundles(_response);
        });
    }

    protected processGetBundles(response: AxiosResponse): Promise<ProjectBundleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectBundleDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectBundleDto[]>(<any>null);
    }

    saveBundle(id: number, state: ProjectBundleStateDto , cancelToken?: CancelToken | undefined): Promise<ProjectChangeResultOfProjectBundleStateDto> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}/bundles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveBundle(_response);
        });
    }

    protected processSaveBundle(response: AxiosResponse): Promise<ProjectChangeResultOfProjectBundleStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectChangeResultOfProjectBundleStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectChangeResultOfProjectBundleStateDto>(<any>null);
    }

    getBundle(id: number, bundleId: number , cancelToken?: CancelToken | undefined): Promise<ProjectBundleStateDto> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}/bundles/{bundleId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (bundleId === undefined || bundleId === null)
            throw new Error("The parameter 'bundleId' must be defined.");
        url_ = url_.replace("{bundleId}", encodeURIComponent("" + bundleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBundle(_response);
        });
    }

    protected processGetBundle(response: AxiosResponse): Promise<ProjectBundleStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectBundleStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectBundleStateDto>(<any>null);
    }

    deleteBundle(id: number, bundleId: number , cancelToken?: CancelToken | undefined): Promise<ProjectChangeResultOfProjectBundleStateDto> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}/bundles/{bundleId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (bundleId === undefined || bundleId === null)
            throw new Error("The parameter 'bundleId' must be defined.");
        url_ = url_.replace("{bundleId}", encodeURIComponent("" + bundleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteBundle(_response);
        });
    }

    protected processDeleteBundle(response: AxiosResponse): Promise<ProjectChangeResultOfProjectBundleStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectChangeResultOfProjectBundleStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectChangeResultOfProjectBundleStateDto>(<any>null);
    }

    getBundlePrice(id: number, state: ProjectBundleStateDto , cancelToken?: CancelToken | undefined): Promise<ProjectBundlePricesDto> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}/bundles/price";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBundlePrice(_response);
        });
    }

    protected processGetBundlePrice(response: AxiosResponse): Promise<ProjectBundlePricesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectBundlePricesDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectBundlePricesDto>(<any>null);
    }

    batchCreate(command: CreateProjectCommandDto[] , cancelToken?: CancelToken | undefined): Promise<ProjectStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/projects/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchCreate(_response);
        });
    }

    protected processBatchCreate(response: AxiosResponse): Promise<ProjectStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectStateDto[]>(<any>null);
    }

    batchUpdate(state: ProjectStateDto[] , cancelToken?: CancelToken | undefined): Promise<ProjectStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/projects/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchUpdate(_response);
        });
    }

    protected processBatchUpdate(response: AxiosResponse): Promise<ProjectStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectStateDto[]>(<any>null);
    }

    publish(id: number , cancelToken?: CancelToken | undefined): Promise<ProjectStateDto> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<ProjectStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectStateDto.fromJS(resultData200);
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationErrorResponseDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectStateDto>(<any>null);
    }

    batchPublish(idx: number[] , cancelToken?: CancelToken | undefined): Promise<{ [key: string]: ProjectState; }> {
        let url_ = this.baseUrl + "/api/catalog/projects/publish/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchPublish(_response);
        });
    }

    protected processBatchPublish(response: AxiosResponse): Promise<{ [key: string]: ProjectState; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: ProjectState; }>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<ProjectStateDto> {
        let url_ = this.baseUrl + "/api/catalog/projects/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<ProjectStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectStateDto>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<{ [key: string]: ProjectState; }> {
        let url_ = this.baseUrl + "/api/catalog/projects/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<{ [key: string]: ProjectState; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: ProjectState; }>(<any>null);
    }
}

export class ProjectTypesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<ProjectTypeDto[]> {
        let url_ = this.baseUrl + "/api/catalog/project-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ProjectTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTypeDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectTypeDto[]>(<any>null);
    }

    save(state: ProjectTypeStateDto , cancelToken?: CancelToken | undefined): Promise<ProjectTypeStateDto> {
        let url_ = this.baseUrl + "/api/catalog/project-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<ProjectTypeStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectTypeStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectTypeStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<ProjectTypeStateDto> {
        let url_ = this.baseUrl + "/api/catalog/project-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ProjectTypeStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectTypeStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectTypeStateDto>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/catalog/project-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    batchSave(state: ProjectTypeStateDto[] , cancelToken?: CancelToken | undefined): Promise<ProjectTypeStateDto[]> {
        let url_ = this.baseUrl + "/api/catalog/project-types/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<ProjectTypeStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectTypeStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectTypeStateDto[]>(<any>null);
    }
}

export class RedirectRulesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(oldSlug: string | null | undefined, newSlug: string | null | undefined, pageNo: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfRedirectRuleDto> {
        let url_ = this.baseUrl + "/api/redirect-rules?";
        if (oldSlug !== undefined && oldSlug !== null)
            url_ += "OldSlug=" + encodeURIComponent("" + oldSlug) + "&";
        if (newSlug !== undefined && newSlug !== null)
            url_ += "NewSlug=" + encodeURIComponent("" + newSlug) + "&";
        if (pageNo === null)
            throw new Error("The parameter 'pageNo' cannot be null.");
        else if (pageNo !== undefined)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PagedResultOfRedirectRuleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfRedirectRuleDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfRedirectRuleDto>(<any>null);
    }

    save(state: RedirectRuleDto , cancelToken?: CancelToken | undefined): Promise<RedirectRuleDto> {
        let url_ = this.baseUrl + "/api/redirect-rules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<RedirectRuleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RedirectRuleDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RedirectRuleDto>(<any>null);
    }

    batchSave(state: RedirectRuleDto[] , cancelToken?: CancelToken | undefined): Promise<RedirectRuleDto[]> {
        let url_ = this.baseUrl + "/api/redirect-rules/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<RedirectRuleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RedirectRuleDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RedirectRuleDto[]>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/redirect-rules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class RegionsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<RegionDto[]> {
        let url_ = this.baseUrl + "/api/geo/regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<RegionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionDto[]>(<any>null);
    }

    save(state: RegionStateDto , cancelToken?: CancelToken | undefined): Promise<RegionStateDto> {
        let url_ = this.baseUrl + "/api/geo/regions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<RegionStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegionStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionStateDto>(<any>null);
    }

    get(id: number , cancelToken?: CancelToken | undefined): Promise<RegionStateDto> {
        let url_ = this.baseUrl + "/api/geo/regions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<RegionStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegionStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionStateDto>(<any>null);
    }

    batchSave(state: RegionStateDto[] , cancelToken?: CancelToken | undefined): Promise<RegionStateDto[]> {
        let url_ = this.baseUrl + "/api/geo/regions/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<RegionStateDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionStateDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionStateDto[]>(<any>null);
    }

    remove(id: number , cancelToken?: CancelToken | undefined): Promise<RegionStateDto> {
        let url_ = this.baseUrl + "/api/geo/regions/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: AxiosResponse): Promise<RegionStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegionStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionStateDto>(<any>null);
    }

    batchRemove(idx: number[] , cancelToken?: CancelToken | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/geo/regions/remove/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(idx);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchRemove(_response);
        });
    }

    protected processBatchRemove(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class RolesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/system/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export class SettingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    getAll(  cancelToken?: CancelToken | undefined): Promise<SettingDto[]> {
        let url_ = this.baseUrl + "/api/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<SettingDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SettingDto[]>(<any>null);
    }

    save(state: SettingStateDto , cancelToken?: CancelToken | undefined): Promise<SettingDto> {
        let url_ = this.baseUrl + "/api/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<SettingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SettingDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SettingDto>(<any>null);
    }

    batchSave(state: SettingStateDto[] , cancelToken?: CancelToken | undefined): Promise<SettingDto[]> {
        let url_ = this.baseUrl + "/api/settings/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBatchSave(_response);
        });
    }

    protected processBatchSave(response: AxiosResponse): Promise<SettingDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SettingDto[]>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/settings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class SystemClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    cleanup(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/system/data/cleanup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCleanup(_response);
        });
    }

    protected processCleanup(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "https://";
    }

    search(phoneNumber: string | null | undefined, email: string | null | undefined, userName: string | null | undefined, roles: string[] | null | undefined, pageNo: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultOfUserDto> {
        let url_ = this.baseUrl + "/api/system/users?";
        if (phoneNumber !== undefined && phoneNumber !== null)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (roles !== undefined && roles !== null)
            roles && roles.forEach(item => { url_ += "Roles=" + encodeURIComponent("" + item) + "&"; });
        if (pageNo === null)
            throw new Error("The parameter 'pageNo' cannot be null.");
        else if (pageNo !== undefined)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<PagedResultOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfUserDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfUserDto>(<any>null);
    }

    create(command: CreateUserCommand , cancelToken?: CancelToken | undefined): Promise<CreateUserCommandResult> {
        let url_ = this.baseUrl + "/api/system/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<CreateUserCommandResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateUserCommandResult.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateUserCommandResult>(<any>null);
    }

    save(state: UserStateDto , cancelToken?: CancelToken | undefined): Promise<UserStateDto> {
        let url_ = this.baseUrl + "/api/system/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: AxiosResponse): Promise<UserStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserStateDto>(<any>null);
    }

    getById(id: number , cancelToken?: CancelToken | undefined): Promise<UserStateDto> {
        let url_ = this.baseUrl + "/api/system/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<UserStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserStateDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserStateDto>(<any>null);
    }

    delete(id: number , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/system/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }

    block(id: number, blocked: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/system/users/{id}/block?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (blocked === null)
            throw new Error("The parameter 'blocked' cannot be null.");
        else if (blocked !== undefined)
            url_ += "blocked=" + encodeURIComponent("" + blocked) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlock(_response);
        });
    }

    protected processBlock(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class LoginReply implements ILoginReply {
    token?: string | undefined;
    userName?: string | undefined;
    expires!: Date;
    roles?: string[] | undefined;

    constructor(data?: ILoginReply) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userName = _data["userName"];
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): LoginReply {
        data = typeof data === 'object' ? data : {};
        let result = new LoginReply();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userName"] = this.userName;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface ILoginReply {
    token?: string | undefined;
    userName?: string | undefined;
    expires: Date;
    roles?: string[] | undefined;
}

export class LoginCommand implements ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;
}

export class ArchitectDto implements IArchitectDto {
    id!: number;
    name?: string | undefined;
    projectSeries?: number | undefined;

    constructor(data?: IArchitectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.projectSeries = _data["projectSeries"];
        }
    }

    static fromJS(data: any): ArchitectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ArchitectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["projectSeries"] = this.projectSeries;
        return data; 
    }
}

export interface IArchitectDto {
    id: number;
    name?: string | undefined;
    projectSeries?: number | undefined;
}

export class ArchitectStateDto implements IArchitectStateDto {
    id?: number | undefined;
    name?: string | undefined;
    projectSeries?: number | undefined;
    users?: number[] | undefined;

    constructor(data?: IArchitectStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.projectSeries = _data["projectSeries"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
        }
    }

    static fromJS(data: any): ArchitectStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ArchitectStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["projectSeries"] = this.projectSeries;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        return data; 
    }
}

export interface IArchitectStateDto {
    id?: number | undefined;
    name?: string | undefined;
    projectSeries?: number | undefined;
    users?: number[] | undefined;
}

export class UserDto implements IUserDto {
    id!: number;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUserDto {
    id: number;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
}

export class AreaDto implements IAreaDto {
    id!: number;
    order!: number;
    name?: string | undefined;

    constructor(data?: IAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAreaDto {
    id: number;
    order: number;
    name?: string | undefined;
}

export class AreaStateDto implements IAreaStateDto {
    id?: number | undefined;
    order!: number;
    name?: string | undefined;

    constructor(data?: IAreaStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AreaStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAreaStateDto {
    id?: number | undefined;
    order: number;
    name?: string | undefined;
}

export class BundleDto implements IBundleDto {
    id!: number;
    order?: string | undefined;
    name?: string | undefined;
    default!: boolean;
    discount!: number;

    constructor(data?: IBundleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
            this.name = _data["name"];
            this.default = _data["default"];
            this.discount = _data["discount"];
        }
    }

    static fromJS(data: any): BundleDto {
        data = typeof data === 'object' ? data : {};
        let result = new BundleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        data["name"] = this.name;
        data["default"] = this.default;
        data["discount"] = this.discount;
        return data; 
    }
}

export interface IBundleDto {
    id: number;
    order?: string | undefined;
    name?: string | undefined;
    default: boolean;
    discount: number;
}

export class BundleStateDto implements IBundleStateDto {
    id?: number | undefined;
    projectTypeId!: number;
    order!: number;
    name?: string | undefined;
    default!: boolean;
    discount!: number;
    options?: BundleOptionStateDto[] | undefined;

    constructor(data?: IBundleStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.order = _data["order"];
            this.name = _data["name"];
            this.default = _data["default"];
            this.discount = _data["discount"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(BundleOptionStateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BundleStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BundleStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["order"] = this.order;
        data["name"] = this.name;
        data["default"] = this.default;
        data["discount"] = this.discount;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBundleStateDto {
    id?: number | undefined;
    projectTypeId: number;
    order: number;
    name?: string | undefined;
    default: boolean;
    discount: number;
    options?: BundleOptionStateDto[] | undefined;
}

export class BundleOptionStateDto implements IBundleOptionStateDto {
    optionId!: number;
    count!: number;

    constructor(data?: IBundleOptionStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.optionId = _data["optionId"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): BundleOptionStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BundleOptionStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["optionId"] = this.optionId;
        data["count"] = this.count;
        return data; 
    }
}

export interface IBundleOptionStateDto {
    optionId: number;
    count: number;
}

export class CategorySchemaDto implements ICategorySchemaDto {
    id!: number;
    created!: Date;
    published?: Date | undefined;
    isPublished!: boolean;
    isDraft!: boolean;

    constructor(data?: ICategorySchemaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.published = _data["published"] ? new Date(_data["published"].toString()) : <any>undefined;
            this.isPublished = _data["isPublished"];
            this.isDraft = _data["isDraft"];
        }
    }

    static fromJS(data: any): CategorySchemaDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["published"] = this.published ? this.published.toISOString() : <any>undefined;
        data["isPublished"] = this.isPublished;
        data["isDraft"] = this.isDraft;
        return data; 
    }
}

export interface ICategorySchemaDto {
    id: number;
    created: Date;
    published?: Date | undefined;
    isPublished: boolean;
    isDraft: boolean;
}

export class CreateCategorySchemaCommandDto implements ICreateCategorySchemaCommandDto {
    schemaId?: number | undefined;

    constructor(data?: ICreateCategorySchemaCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static fromJS(data: any): CreateCategorySchemaCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategorySchemaCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        return data; 
    }
}

export interface ICreateCategorySchemaCommandDto {
    schemaId?: number | undefined;
}

export class CategorySchemaStateDto implements ICategorySchemaStateDto {
    id!: number;
    separator?: string | undefined;
    titleTemplate?: string | undefined;
    metaKeywordsTemplate?: string | undefined;
    metaDescriptionTemplate?: string | undefined;
    h1Template?: string | undefined;
    descriptionTemplate?: string | undefined;
    navLinkTextTemplate?: string | undefined;
    navLinkTitleTemplate?: string | undefined;
    firstNavLinkTextTemplate?: string | undefined;
    firstNavLinkTitleTemplate?: string | undefined;
    menuLinkTextTemplate?: string | undefined;
    menuLinkTitleTemplate?: string | undefined;
    headerNavLinkTextTemplate?: string | undefined;
    headerNavLinkTitleTemplate?: string | undefined;

    constructor(data?: ICategorySchemaStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.separator = _data["separator"];
            this.titleTemplate = _data["titleTemplate"];
            this.metaKeywordsTemplate = _data["metaKeywordsTemplate"];
            this.metaDescriptionTemplate = _data["metaDescriptionTemplate"];
            this.h1Template = _data["h1Template"];
            this.descriptionTemplate = _data["descriptionTemplate"];
            this.navLinkTextTemplate = _data["navLinkTextTemplate"];
            this.navLinkTitleTemplate = _data["navLinkTitleTemplate"];
            this.firstNavLinkTextTemplate = _data["firstNavLinkTextTemplate"];
            this.firstNavLinkTitleTemplate = _data["firstNavLinkTitleTemplate"];
            this.menuLinkTextTemplate = _data["menuLinkTextTemplate"];
            this.menuLinkTitleTemplate = _data["menuLinkTitleTemplate"];
            this.headerNavLinkTextTemplate = _data["headerNavLinkTextTemplate"];
            this.headerNavLinkTitleTemplate = _data["headerNavLinkTitleTemplate"];
        }
    }

    static fromJS(data: any): CategorySchemaStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["separator"] = this.separator;
        data["titleTemplate"] = this.titleTemplate;
        data["metaKeywordsTemplate"] = this.metaKeywordsTemplate;
        data["metaDescriptionTemplate"] = this.metaDescriptionTemplate;
        data["h1Template"] = this.h1Template;
        data["descriptionTemplate"] = this.descriptionTemplate;
        data["navLinkTextTemplate"] = this.navLinkTextTemplate;
        data["navLinkTitleTemplate"] = this.navLinkTitleTemplate;
        data["firstNavLinkTextTemplate"] = this.firstNavLinkTextTemplate;
        data["firstNavLinkTitleTemplate"] = this.firstNavLinkTitleTemplate;
        data["menuLinkTextTemplate"] = this.menuLinkTextTemplate;
        data["menuLinkTitleTemplate"] = this.menuLinkTitleTemplate;
        data["headerNavLinkTextTemplate"] = this.headerNavLinkTextTemplate;
        data["headerNavLinkTitleTemplate"] = this.headerNavLinkTitleTemplate;
        return data; 
    }
}

export interface ICategorySchemaStateDto {
    id: number;
    separator?: string | undefined;
    titleTemplate?: string | undefined;
    metaKeywordsTemplate?: string | undefined;
    metaDescriptionTemplate?: string | undefined;
    h1Template?: string | undefined;
    descriptionTemplate?: string | undefined;
    navLinkTextTemplate?: string | undefined;
    navLinkTitleTemplate?: string | undefined;
    firstNavLinkTextTemplate?: string | undefined;
    firstNavLinkTitleTemplate?: string | undefined;
    menuLinkTextTemplate?: string | undefined;
    menuLinkTitleTemplate?: string | undefined;
    headerNavLinkTextTemplate?: string | undefined;
    headerNavLinkTitleTemplate?: string | undefined;
}

export class PublishCategorySchemaCommandDto implements IPublishCategorySchemaCommandDto {
    schemaId!: number;

    constructor(data?: IPublishCategorySchemaCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schemaId = _data["schemaId"];
        }
    }

    static fromJS(data: any): PublishCategorySchemaCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishCategorySchemaCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schemaId"] = this.schemaId;
        return data; 
    }
}

export interface IPublishCategorySchemaCommandDto {
    schemaId: number;
}

export class ValueTupleOfStringAndString implements IValueTupleOfStringAndString {
    item1!: string;
    item2!: string;

    constructor(data?: IValueTupleOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any): ValueTupleOfStringAndString {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTupleOfStringAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data; 
    }
}

export interface IValueTupleOfStringAndString {
    item1: string;
    item2: string;
}

export class CategorySchemaProjectTypeDto implements ICategorySchemaProjectTypeDto {
    id?: number | undefined;
    projectTypeId!: number;
    projectType?: string | undefined;
    order!: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;

    constructor(data?: ICategorySchemaProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.projectType = _data["projectType"];
            this.order = _data["order"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.h1 = _data["h1"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.menuLinkText = _data["menuLinkText"];
            this.menuLinkTitle = _data["menuLinkTitle"];
        }
    }

    static fromJS(data: any): CategorySchemaProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["projectType"] = this.projectType;
        data["order"] = this.order;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["h1"] = this.h1;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["menuLinkText"] = this.menuLinkText;
        data["menuLinkTitle"] = this.menuLinkTitle;
        return data; 
    }
}

export interface ICategorySchemaProjectTypeDto {
    id?: number | undefined;
    projectTypeId: number;
    projectType?: string | undefined;
    order: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
}

export class CategorySchemaProjectTypeStateDto implements ICategorySchemaProjectTypeStateDto {
    id?: number | undefined;
    projectTypeId!: number;
    order!: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;

    constructor(data?: ICategorySchemaProjectTypeStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.order = _data["order"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.h1 = _data["h1"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.menuLinkText = _data["menuLinkText"];
            this.menuLinkTitle = _data["menuLinkTitle"];
        }
    }

    static fromJS(data: any): CategorySchemaProjectTypeStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaProjectTypeStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["order"] = this.order;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["h1"] = this.h1;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["menuLinkText"] = this.menuLinkText;
        data["menuLinkTitle"] = this.menuLinkTitle;
        return data; 
    }
}

export interface ICategorySchemaProjectTypeStateDto {
    id?: number | undefined;
    projectTypeId: number;
    order: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
}

export class CategorySchemaCityDto implements ICategorySchemaCityDto {
    id?: number | undefined;
    cityId!: number;
    city?: string | undefined;
    order!: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;

    constructor(data?: ICategorySchemaCityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cityId = _data["cityId"];
            this.city = _data["city"];
            this.order = _data["order"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.h1 = _data["h1"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.menuLinkText = _data["menuLinkText"];
            this.menuLinkTitle = _data["menuLinkTitle"];
        }
    }

    static fromJS(data: any): CategorySchemaCityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaCityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cityId"] = this.cityId;
        data["city"] = this.city;
        data["order"] = this.order;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["h1"] = this.h1;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["menuLinkText"] = this.menuLinkText;
        data["menuLinkTitle"] = this.menuLinkTitle;
        return data; 
    }
}

export interface ICategorySchemaCityDto {
    id?: number | undefined;
    cityId: number;
    city?: string | undefined;
    order: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
}

export class CategorySchemaCityStateDto implements ICategorySchemaCityStateDto {
    id?: number | undefined;
    cityId!: number;
    order!: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;

    constructor(data?: ICategorySchemaCityStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cityId = _data["cityId"];
            this.order = _data["order"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.h1 = _data["h1"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.menuLinkText = _data["menuLinkText"];
            this.menuLinkTitle = _data["menuLinkTitle"];
        }
    }

    static fromJS(data: any): CategorySchemaCityStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaCityStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cityId"] = this.cityId;
        data["order"] = this.order;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["h1"] = this.h1;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["menuLinkText"] = this.menuLinkText;
        data["menuLinkTitle"] = this.menuLinkTitle;
        return data; 
    }
}

export interface ICategorySchemaCityStateDto {
    id?: number | undefined;
    cityId: number;
    order: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
}

export class CategorySchemaGroupDto implements ICategorySchemaGroupDto {
    id!: number;
    projectTypeId!: number;
    projectType?: string | undefined;
    order!: number;
    name?: string | undefined;

    constructor(data?: ICategorySchemaGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.projectType = _data["projectType"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategorySchemaGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["projectType"] = this.projectType;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategorySchemaGroupDto {
    id: number;
    projectTypeId: number;
    projectType?: string | undefined;
    order: number;
    name?: string | undefined;
}

export class CategorySchemaGroupStateDto implements ICategorySchemaGroupStateDto {
    id?: number | undefined;
    projectTypeId!: number;
    name?: string | undefined;
    order!: number;

    constructor(data?: ICategorySchemaGroupStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.name = _data["name"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CategorySchemaGroupStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaGroupStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["name"] = this.name;
        data["order"] = this.order;
        return data; 
    }
}

export interface ICategorySchemaGroupStateDto {
    id?: number | undefined;
    projectTypeId: number;
    name?: string | undefined;
    order: number;
}

export class CategorySchemaUiGroupDto implements ICategorySchemaUiGroupDto {
    id!: number;
    projectTypeId!: number;
    projectType?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICategorySchemaUiGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.projectType = _data["projectType"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategorySchemaUiGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaUiGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["projectType"] = this.projectType;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategorySchemaUiGroupDto {
    id: number;
    projectTypeId: number;
    projectType?: string | undefined;
    name?: string | undefined;
}

export class CategorySchemaUiGroupStateDto implements ICategorySchemaUiGroupStateDto {
    id?: number | undefined;
    projectTypeId!: number;
    name?: string | undefined;
    order!: number;

    constructor(data?: ICategorySchemaUiGroupStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.name = _data["name"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CategorySchemaUiGroupStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaUiGroupStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["name"] = this.name;
        data["order"] = this.order;
        return data; 
    }
}

export interface ICategorySchemaUiGroupStateDto {
    id?: number | undefined;
    projectTypeId: number;
    name?: string | undefined;
    order: number;
}

export class CategorySchemaElementDto implements ICategorySchemaElementDto {
    id!: number;
    projectTypeId!: number;
    projectTypeOrder!: number;
    projectType?: string | undefined;
    groupId!: number;
    groupOrder!: number;
    group?: string | undefined;
    uiGroupId!: number;
    uiGroupOrder!: number;
    uiGroup?: string | undefined;
    order!: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;

    constructor(data?: ICategorySchemaElementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.projectTypeOrder = _data["projectTypeOrder"];
            this.projectType = _data["projectType"];
            this.groupId = _data["groupId"];
            this.groupOrder = _data["groupOrder"];
            this.group = _data["group"];
            this.uiGroupId = _data["uiGroupId"];
            this.uiGroupOrder = _data["uiGroupOrder"];
            this.uiGroup = _data["uiGroup"];
            this.order = _data["order"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.h1 = _data["h1"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.menuLinkText = _data["menuLinkText"];
            this.menuLinkTitle = _data["menuLinkTitle"];
        }
    }

    static fromJS(data: any): CategorySchemaElementDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaElementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["projectTypeOrder"] = this.projectTypeOrder;
        data["projectType"] = this.projectType;
        data["groupId"] = this.groupId;
        data["groupOrder"] = this.groupOrder;
        data["group"] = this.group;
        data["uiGroupId"] = this.uiGroupId;
        data["uiGroupOrder"] = this.uiGroupOrder;
        data["uiGroup"] = this.uiGroup;
        data["order"] = this.order;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["h1"] = this.h1;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["menuLinkText"] = this.menuLinkText;
        data["menuLinkTitle"] = this.menuLinkTitle;
        return data; 
    }
}

export interface ICategorySchemaElementDto {
    id: number;
    projectTypeId: number;
    projectTypeOrder: number;
    projectType?: string | undefined;
    groupId: number;
    groupOrder: number;
    group?: string | undefined;
    uiGroupId: number;
    uiGroupOrder: number;
    uiGroup?: string | undefined;
    order: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
}

export class CategorySchemaElementStateDto implements ICategorySchemaElementStateDto {
    id?: number | undefined;
    groupId!: number;
    uiGroupId?: number | undefined;
    order!: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    description?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
    properties?: CategorySchemaPropertyDto[] | undefined;

    constructor(data?: ICategorySchemaElementStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.uiGroupId = _data["uiGroupId"];
            this.order = _data["order"];
            this.slug = _data["slug"];
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.h1 = _data["h1"];
            this.description = _data["description"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.menuLinkText = _data["menuLinkText"];
            this.menuLinkTitle = _data["menuLinkTitle"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(CategorySchemaPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategorySchemaElementStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaElementStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["uiGroupId"] = this.uiGroupId;
        data["order"] = this.order;
        data["slug"] = this.slug;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["h1"] = this.h1;
        data["description"] = this.description;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["menuLinkText"] = this.menuLinkText;
        data["menuLinkTitle"] = this.menuLinkTitle;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICategorySchemaElementStateDto {
    id?: number | undefined;
    groupId: number;
    uiGroupId?: number | undefined;
    order: number;
    slug?: string | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    description?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
    properties?: CategorySchemaPropertyDto[] | undefined;
}

export class CategorySchemaPropertyDto implements ICategorySchemaPropertyDto {
    property?: string | undefined;
    value?: string | undefined;

    constructor(data?: ICategorySchemaPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.property = _data["property"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CategorySchemaPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["property"] = this.property;
        data["value"] = this.value;
        return data; 
    }
}

export interface ICategorySchemaPropertyDto {
    property?: string | undefined;
    value?: string | undefined;
}

export class CategorySchemaContentDto implements ICategorySchemaContentDto {
    id!: number;
    slug?: string | undefined;

    constructor(data?: ICategorySchemaContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): CategorySchemaContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["slug"] = this.slug;
        return data; 
    }
}

export interface ICategorySchemaContentDto {
    id: number;
    slug?: string | undefined;
}

export class CategorySchemaContentStateDto implements ICategorySchemaContentStateDto {
    id?: number | undefined;
    projectTypeId?: number | undefined;
    cityId?: number | undefined;
    elements?: number[] | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    description?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
    properties?: CategorySchemaPropertyDto[] | undefined;

    constructor(data?: ICategorySchemaContentStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.cityId = _data["cityId"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(item);
            }
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.h1 = _data["h1"];
            this.description = _data["description"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.menuLinkText = _data["menuLinkText"];
            this.menuLinkTitle = _data["menuLinkTitle"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(CategorySchemaPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategorySchemaContentStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySchemaContentStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["cityId"] = this.cityId;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item);
        }
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["h1"] = this.h1;
        data["description"] = this.description;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["menuLinkText"] = this.menuLinkText;
        data["menuLinkTitle"] = this.menuLinkTitle;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICategorySchemaContentStateDto {
    id?: number | undefined;
    projectTypeId?: number | undefined;
    cityId?: number | undefined;
    elements?: number[] | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    h1?: string | undefined;
    description?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    menuLinkText?: string | undefined;
    menuLinkTitle?: string | undefined;
    properties?: CategorySchemaPropertyDto[] | undefined;
}

export class CityDto implements ICityDto {
    id!: number;
    areaId!: number;
    area?: string | undefined;
    regionId!: number;
    region?: string | undefined;
    order!: number;
    name?: string | undefined;

    constructor(data?: ICityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.areaId = _data["areaId"];
            this.area = _data["area"];
            this.regionId = _data["regionId"];
            this.region = _data["region"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["areaId"] = this.areaId;
        data["area"] = this.area;
        data["regionId"] = this.regionId;
        data["region"] = this.region;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICityDto {
    id: number;
    areaId: number;
    area?: string | undefined;
    regionId: number;
    region?: string | undefined;
    order: number;
    name?: string | undefined;
}

export class CityStateDto implements ICityStateDto {
    id?: number | undefined;
    regionId!: number;
    order!: number;
    name?: string | undefined;

    constructor(data?: ICityStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.regionId = _data["regionId"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CityStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["regionId"] = this.regionId;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICityStateDto {
    id?: number | undefined;
    regionId: number;
    order: number;
    name?: string | undefined;
}

export class CollectionDto implements ICollectionDto {
    id!: number;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICollectionDto {
    id: number;
    code?: string | undefined;
    name?: string | undefined;
}

export class CollectionStateDto implements ICollectionStateDto {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    categorySlug?: string | undefined;
    projects?: number[] | undefined;

    constructor(data?: ICollectionStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.categorySlug = _data["categorySlug"];
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(item);
            }
        }
    }

    static fromJS(data: any): CollectionStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["categorySlug"] = this.categorySlug;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item);
        }
        return data; 
    }
}

export interface ICollectionStateDto {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    categorySlug?: string | undefined;
    projects?: number[] | undefined;
}

export class PagedResultOfCategoryDto implements IPagedResultOfCategoryDto {
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    firstRowOnPage!: number;
    lastRowOnPage!: number;
    isLastPage!: boolean;
    items?: CategoryDto[] | undefined;

    constructor(data?: IPagedResultOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
            this.isLastPage = _data["isLastPage"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["isLastPage"] = this.isLastPage;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultOfCategoryDto {
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    firstRowOnPage: number;
    lastRowOnPage: number;
    isLastPage: boolean;
    items?: CategoryDto[] | undefined;
}

export class CategoryDto implements ICategoryDto {
    id!: number;
    state!: ContentCategoryState;
    url?: string | undefined;
    name?: string | undefined;
    createdAt!: Date;
    modifiedAt!: Date;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["url"] = this.url;
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICategoryDto {
    id: number;
    state: ContentCategoryState;
    url?: string | undefined;
    name?: string | undefined;
    createdAt: Date;
    modifiedAt: Date;
}

export enum ContentCategoryState {
    Draft = 0,
    Published = 1,
    Removed = 2,
}

export class CategoryStateDto implements ICategoryStateDto {
    id?: number | undefined;
    state!: ContentCategoryState;
    url?: string | undefined;
    parentId?: number | undefined;
    image?: ImageDto | undefined;
    createdAt?: Date | undefined;
    modifiedAt?: Date | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    shortDescription?: string | undefined;

    constructor(data?: ICategoryStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.url = _data["url"];
            this.parentId = _data["parentId"];
            this.image = _data["image"] ? ImageDto.fromJS(_data["image"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.shortName = _data["shortName"];
            this.shortDescription = _data["shortDescription"];
        }
    }

    static fromJS(data: any): CategoryStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["url"] = this.url;
        data["parentId"] = this.parentId;
        data["image"] = this.image ? this.image.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["name"] = this.name;
        data["description"] = this.description;
        data["shortName"] = this.shortName;
        data["shortDescription"] = this.shortDescription;
        return data; 
    }
}

export interface ICategoryStateDto {
    id?: number | undefined;
    state: ContentCategoryState;
    url?: string | undefined;
    parentId?: number | undefined;
    image?: ImageDto | undefined;
    createdAt?: Date | undefined;
    modifiedAt?: Date | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    shortDescription?: string | undefined;
}

export class ImageDto implements IImageDto {
    id!: number;
    url?: string | undefined;

    constructor(data?: IImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        return data; 
    }
}

export interface IImageDto {
    id: number;
    url?: string | undefined;
}

export class CategoryOverrideCommand implements ICategoryOverrideCommand {
    createdAt?: Date | undefined;
    publishedAt?: Date | undefined;
    deletedAt?: Date | undefined;
    url?: string[] | undefined;

    constructor(data?: ICategoryOverrideCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.publishedAt = _data["publishedAt"] ? new Date(_data["publishedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["url"])) {
                this.url = [] as any;
                for (let item of _data["url"])
                    this.url!.push(item);
            }
        }
    }

    static fromJS(data: any): CategoryOverrideCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryOverrideCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["publishedAt"] = this.publishedAt ? this.publishedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.url)) {
            data["url"] = [];
            for (let item of this.url)
                data["url"].push(item);
        }
        return data; 
    }
}

export interface ICategoryOverrideCommand {
    createdAt?: Date | undefined;
    publishedAt?: Date | undefined;
    deletedAt?: Date | undefined;
    url?: string[] | undefined;
}

export class PublishCategoryOptions implements IPublishCategoryOptions {
    url?: string | undefined;

    constructor(data?: IPublishCategoryOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): PublishCategoryOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PublishCategoryOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IPublishCategoryOptions {
    url?: string | undefined;
}

export class PagedResultOfPostDto implements IPagedResultOfPostDto {
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    firstRowOnPage!: number;
    lastRowOnPage!: number;
    isLastPage!: boolean;
    items?: PostDto[] | undefined;

    constructor(data?: IPagedResultOfPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
            this.isLastPage = _data["isLastPage"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PostDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["isLastPage"] = this.isLastPage;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultOfPostDto {
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    firstRowOnPage: number;
    lastRowOnPage: number;
    isLastPage: boolean;
    items?: PostDto[] | undefined;
}

export class PostDto implements IPostDto {
    id!: number;
    state!: ContentPostState;
    url?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    createdAt!: Date;
    modifiedAt!: Date;

    constructor(data?: IPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["url"] = this.url;
        data["name"] = this.name;
        data["category"] = this.category;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPostDto {
    id: number;
    state: ContentPostState;
    url?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    createdAt: Date;
    modifiedAt: Date;
}

export enum ContentPostState {
    Draft = 0,
    Published = 1,
    Removed = 2,
}

export class PostStateDto implements IPostStateDto {
    id?: number | undefined;
    state!: ContentPostState;
    categoryId!: number;
    url?: string | undefined;
    image?: ImageDto | undefined;
    createdAt?: Date | undefined;
    modifiedAt?: Date | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    shortDescription?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    tags?: number[] | undefined;

    constructor(data?: IPostStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.categoryId = _data["categoryId"];
            this.url = _data["url"];
            this.image = _data["image"] ? ImageDto.fromJS(_data["image"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.shortName = _data["shortName"];
            this.shortDescription = _data["shortDescription"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): PostStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["categoryId"] = this.categoryId;
        data["url"] = this.url;
        data["image"] = this.image ? this.image.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["name"] = this.name;
        data["description"] = this.description;
        data["shortName"] = this.shortName;
        data["shortDescription"] = this.shortDescription;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data; 
    }
}

export interface IPostStateDto {
    id?: number | undefined;
    state: ContentPostState;
    categoryId: number;
    url?: string | undefined;
    image?: ImageDto | undefined;
    createdAt?: Date | undefined;
    modifiedAt?: Date | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    shortDescription?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    tags?: number[] | undefined;
}

export class PostOverrideCommand implements IPostOverrideCommand {
    createdAt?: Date | undefined;
    publishedAt?: Date | undefined;
    deletedAt?: Date | undefined;
    url?: string[] | undefined;

    constructor(data?: IPostOverrideCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.publishedAt = _data["publishedAt"] ? new Date(_data["publishedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["url"])) {
                this.url = [] as any;
                for (let item of _data["url"])
                    this.url!.push(item);
            }
        }
    }

    static fromJS(data: any): PostOverrideCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PostOverrideCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["publishedAt"] = this.publishedAt ? this.publishedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.url)) {
            data["url"] = [];
            for (let item of this.url)
                data["url"].push(item);
        }
        return data; 
    }
}

export interface IPostOverrideCommand {
    createdAt?: Date | undefined;
    publishedAt?: Date | undefined;
    deletedAt?: Date | undefined;
    url?: string[] | undefined;
}

export class PublishPostOptions implements IPublishPostOptions {
    url?: string | undefined;

    constructor(data?: IPublishPostOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): PublishPostOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PublishPostOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IPublishPostOptions {
    url?: string | undefined;
}

export class PagedResultOfTagDto implements IPagedResultOfTagDto {
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    firstRowOnPage!: number;
    lastRowOnPage!: number;
    isLastPage!: boolean;
    items?: TagDto[] | undefined;

    constructor(data?: IPagedResultOfTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
            this.isLastPage = _data["isLastPage"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["isLastPage"] = this.isLastPage;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultOfTagDto {
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    firstRowOnPage: number;
    lastRowOnPage: number;
    isLastPage: boolean;
    items?: TagDto[] | undefined;
}

export class TagDto implements ITagDto {
    id!: number;
    state!: ContentTagState;
    url?: string | undefined;
    name?: string | undefined;
    createdAt!: Date;
    modifiedAt!: Date;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["url"] = this.url;
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITagDto {
    id: number;
    state: ContentTagState;
    url?: string | undefined;
    name?: string | undefined;
    createdAt: Date;
    modifiedAt: Date;
}

export enum ContentTagState {
    Draft = 0,
    Published = 1,
    Removed = 2,
}

export class TagStateDto implements ITagStateDto {
    id?: number | undefined;
    state!: ContentTagState;
    url?: string | undefined;
    image?: ImageDto | undefined;
    createdAt?: Date | undefined;
    modifiedAt?: Date | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    shortDescription?: string | undefined;

    constructor(data?: ITagStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.url = _data["url"];
            this.image = _data["image"] ? ImageDto.fromJS(_data["image"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.shortName = _data["shortName"];
            this.shortDescription = _data["shortDescription"];
        }
    }

    static fromJS(data: any): TagStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["url"] = this.url;
        data["image"] = this.image ? this.image.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["name"] = this.name;
        data["description"] = this.description;
        data["shortName"] = this.shortName;
        data["shortDescription"] = this.shortDescription;
        return data; 
    }
}

export interface ITagStateDto {
    id?: number | undefined;
    state: ContentTagState;
    url?: string | undefined;
    image?: ImageDto | undefined;
    createdAt?: Date | undefined;
    modifiedAt?: Date | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    shortDescription?: string | undefined;
}

export class PublishTagOptions implements IPublishTagOptions {
    url?: string | undefined;

    constructor(data?: IPublishTagOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): PublishTagOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PublishTagOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IPublishTagOptions {
    url?: string | undefined;
}

export class MaterialDto implements IMaterialDto {
    id!: number;
    groupId?: string | undefined;
    group?: string | undefined;
    value?: string | undefined;

    constructor(data?: IMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.group = _data["group"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["group"] = this.group;
        data["value"] = this.value;
        return data; 
    }
}

export interface IMaterialDto {
    id: number;
    groupId?: string | undefined;
    group?: string | undefined;
    value?: string | undefined;
}

export class MaterialStateDto implements IMaterialStateDto {
    id?: number | undefined;
    groupId!: number;
    value?: string | undefined;

    constructor(data?: IMaterialStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MaterialStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["value"] = this.value;
        return data; 
    }
}

export interface IMaterialStateDto {
    id?: number | undefined;
    groupId: number;
    value?: string | undefined;
}

export class MaterialGroupDto implements IMaterialGroupDto {
    id!: number;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IMaterialGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MaterialGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface IMaterialGroupDto {
    id: number;
    code?: string | undefined;
    name?: string | undefined;
}

export class MaterialGroupStateDto implements IMaterialGroupStateDto {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IMaterialGroupStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MaterialGroupStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialGroupStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface IMaterialGroupStateDto {
    id?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
}

export class PropertyTypeDto implements IPropertyTypeDto {
    code?: string | undefined;
    name?: string | undefined;
    operators?: string[] | undefined;
    editors?: string[] | undefined;

    constructor(data?: IPropertyTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            if (Array.isArray(_data["operators"])) {
                this.operators = [] as any;
                for (let item of _data["operators"])
                    this.operators!.push(item);
            }
            if (Array.isArray(_data["editors"])) {
                this.editors = [] as any;
                for (let item of _data["editors"])
                    this.editors!.push(item);
            }
        }
    }

    static fromJS(data: any): PropertyTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        if (Array.isArray(this.operators)) {
            data["operators"] = [];
            for (let item of this.operators)
                data["operators"].push(item);
        }
        if (Array.isArray(this.editors)) {
            data["editors"] = [];
            for (let item of this.editors)
                data["editors"].push(item);
        }
        return data; 
    }
}

export interface IPropertyTypeDto {
    code?: string | undefined;
    name?: string | undefined;
    operators?: string[] | undefined;
    editors?: string[] | undefined;
}

export class OptionGroupDto implements IOptionGroupDto {
    id!: number;
    order!: number;
    name?: string | undefined;

    constructor(data?: IOptionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OptionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface IOptionGroupDto {
    id: number;
    order: number;
    name?: string | undefined;
}

export class OptionGroupStateDto implements IOptionGroupStateDto {
    id?: number | undefined;
    projectTypeId!: number;
    order!: number;
    name?: string | undefined;

    constructor(data?: IOptionGroupStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OptionGroupStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionGroupStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface IOptionGroupStateDto {
    id?: number | undefined;
    projectTypeId: number;
    order: number;
    name?: string | undefined;
}

export class OptionDto implements IOptionDto {
    id!: number;
    groupId!: number;
    group?: string | undefined;
    name?: string | undefined;

    constructor(data?: IOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.group = _data["group"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["group"] = this.group;
        data["name"] = this.name;
        return data; 
    }
}

export interface IOptionDto {
    id: number;
    groupId: number;
    group?: string | undefined;
    name?: string | undefined;
}

export class OptionStateDto implements IOptionStateDto {
    id?: number | undefined;
    groupId!: number;
    order!: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IOptionStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.order = _data["order"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): OptionStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["order"] = this.order;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IOptionStateDto {
    id?: number | undefined;
    groupId: number;
    order: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class PagedResultOfPageDto implements IPagedResultOfPageDto {
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    firstRowOnPage!: number;
    lastRowOnPage!: number;
    isLastPage!: boolean;
    items?: PageDto[] | undefined;

    constructor(data?: IPagedResultOfPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
            this.isLastPage = _data["isLastPage"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["isLastPage"] = this.isLastPage;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultOfPageDto {
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    firstRowOnPage: number;
    lastRowOnPage: number;
    isLastPage: boolean;
    items?: PageDto[] | undefined;
}

export class PageDto implements IPageDto {
    id!: number;
    parentId?: number | undefined;
    state!: PageState;
    url?: string | undefined;
    name?: string | undefined;
    createdAt!: Date;
    modifiedAt!: Date;

    constructor(data?: IPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.state = _data["state"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["state"] = this.state;
        data["url"] = this.url;
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPageDto {
    id: number;
    parentId?: number | undefined;
    state: PageState;
    url?: string | undefined;
    name?: string | undefined;
    createdAt: Date;
    modifiedAt: Date;
}

export enum PageState {
    Draft = 0,
    Published = 1,
    Removed = 2,
}

export class PageStateDto implements IPageStateDto {
    id?: number | undefined;
    parentId?: number | undefined;
    state!: PageState;
    url?: string | undefined;
    createdAt?: Date | undefined;
    modifiedAt?: Date | undefined;
    image?: ImageDto | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    shortDescription?: string | undefined;

    constructor(data?: IPageStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.state = _data["state"];
            this.url = _data["url"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.modifiedAt = _data["modifiedAt"] ? new Date(_data["modifiedAt"].toString()) : <any>undefined;
            this.image = _data["image"] ? ImageDto.fromJS(_data["image"]) : <any>undefined;
            this.title = _data["title"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.navLinkText = _data["navLinkText"];
            this.navLinkTitle = _data["navLinkTitle"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.shortName = _data["shortName"];
            this.shortDescription = _data["shortDescription"];
        }
    }

    static fromJS(data: any): PageStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["state"] = this.state;
        data["url"] = this.url;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["modifiedAt"] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
        data["image"] = this.image ? this.image.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["navLinkText"] = this.navLinkText;
        data["navLinkTitle"] = this.navLinkTitle;
        data["name"] = this.name;
        data["description"] = this.description;
        data["shortName"] = this.shortName;
        data["shortDescription"] = this.shortDescription;
        return data; 
    }
}

export interface IPageStateDto {
    id?: number | undefined;
    parentId?: number | undefined;
    state: PageState;
    url?: string | undefined;
    createdAt?: Date | undefined;
    modifiedAt?: Date | undefined;
    image?: ImageDto | undefined;
    title?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    navLinkText?: string | undefined;
    navLinkTitle?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    shortName?: string | undefined;
    shortDescription?: string | undefined;
}

export class PageOverrideCommand implements IPageOverrideCommand {
    createdAt?: Date | undefined;
    publishedAt?: Date | undefined;
    deletedAt?: Date | undefined;
    url?: string[] | undefined;

    constructor(data?: IPageOverrideCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.publishedAt = _data["publishedAt"] ? new Date(_data["publishedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["url"])) {
                this.url = [] as any;
                for (let item of _data["url"])
                    this.url!.push(item);
            }
        }
    }

    static fromJS(data: any): PageOverrideCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PageOverrideCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["publishedAt"] = this.publishedAt ? this.publishedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.url)) {
            data["url"] = [];
            for (let item of this.url)
                data["url"].push(item);
        }
        return data; 
    }
}

export interface IPageOverrideCommand {
    createdAt?: Date | undefined;
    publishedAt?: Date | undefined;
    deletedAt?: Date | undefined;
    url?: string[] | undefined;
}

export class PublishPageOptions implements IPublishPageOptions {
    url?: string | undefined;

    constructor(data?: IPublishPageOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): PublishPageOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PublishPageOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }
}

export interface IPublishPageOptions {
    url?: string | undefined;
}

export class PriceListDto implements IPriceListDto {
    id!: number;
    isPublished!: boolean;
    isDraft!: boolean;
    created!: Date;
    published?: Date | undefined;
    archived?: Date | undefined;

    constructor(data?: IPriceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isPublished = _data["isPublished"];
            this.isDraft = _data["isDraft"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.published = _data["published"] ? new Date(_data["published"].toString()) : <any>undefined;
            this.archived = _data["archived"] ? new Date(_data["archived"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PriceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isPublished"] = this.isPublished;
        data["isDraft"] = this.isDraft;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["published"] = this.published ? this.published.toISOString() : <any>undefined;
        data["archived"] = this.archived ? this.archived.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPriceListDto {
    id: number;
    isPublished: boolean;
    isDraft: boolean;
    created: Date;
    published?: Date | undefined;
    archived?: Date | undefined;
}

export class PriceRuleStateDto implements IPriceRuleStateDto {
    id?: number | undefined;
    projectTypeId!: number;
    query?: string | undefined;
    options?: PriceRuleOptionDto[] | undefined;

    constructor(data?: IPriceRuleStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectTypeId = _data["projectTypeId"];
            this.query = _data["query"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(PriceRuleOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PriceRuleStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceRuleStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectTypeId"] = this.projectTypeId;
        data["query"] = this.query;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPriceRuleStateDto {
    id?: number | undefined;
    projectTypeId: number;
    query?: string | undefined;
    options?: PriceRuleOptionDto[] | undefined;
}

export class PriceRuleOptionDto implements IPriceRuleOptionDto {
    optionId!: number;
    price?: string | undefined;

    constructor(data?: IPriceRuleOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.optionId = _data["optionId"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): PriceRuleOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceRuleOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["optionId"] = this.optionId;
        data["price"] = this.price;
        return data; 
    }
}

export interface IPriceRuleOptionDto {
    optionId: number;
    price?: string | undefined;
}

export class PagedResultOfProjectDto implements IPagedResultOfProjectDto {
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    firstRowOnPage!: number;
    lastRowOnPage!: number;
    isLastPage!: boolean;
    items?: ProjectDto[] | undefined;

    constructor(data?: IPagedResultOfProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
            this.isLastPage = _data["isLastPage"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["isLastPage"] = this.isLastPage;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultOfProjectDto {
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    firstRowOnPage: number;
    lastRowOnPage: number;
    isLastPage: boolean;
    items?: ProjectDto[] | undefined;
}

export class ProjectDto implements IProjectDto {
    id!: number;
    created?: Date | undefined;
    state!: ProjectState;
    sku?: string | undefined;
    name?: string | undefined;
    price!: number;
    mainImageUrl?: string | undefined;
    projectTypeId!: number;
    projectType?: string | undefined;
    architectId!: number;
    architect?: string | undefined;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.mainImageUrl = _data["mainImageUrl"];
            this.projectTypeId = _data["projectTypeId"];
            this.projectType = _data["projectType"];
            this.architectId = _data["architectId"];
            this.architect = _data["architect"];
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["mainImageUrl"] = this.mainImageUrl;
        data["projectTypeId"] = this.projectTypeId;
        data["projectType"] = this.projectType;
        data["architectId"] = this.architectId;
        data["architect"] = this.architect;
        return data; 
    }
}

export interface IProjectDto {
    id: number;
    created?: Date | undefined;
    state: ProjectState;
    sku?: string | undefined;
    name?: string | undefined;
    price: number;
    mainImageUrl?: string | undefined;
    projectTypeId: number;
    projectType?: string | undefined;
    architectId: number;
    architect?: string | undefined;
}

export enum ProjectState {
    Draft = 0,
    Published = 1,
    Removed = 2,
}

export enum SpecificationStateType {
    Direct = 0,
    And = 1,
    Or = 2,
}

export class SpecificationState implements ISpecificationState {
    type!: SpecificationStateType;
    property?: string | undefined;
    operator?: string | undefined;
    value?: string | undefined;
    specifications?: SpecificationState[] | undefined;

    constructor(data?: ISpecificationState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.property = _data["property"];
            this.operator = _data["operator"];
            this.value = _data["value"];
            if (Array.isArray(_data["specifications"])) {
                this.specifications = [] as any;
                for (let item of _data["specifications"])
                    this.specifications!.push(SpecificationState.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpecificationState {
        data = typeof data === 'object' ? data : {};
        let result = new SpecificationState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["property"] = this.property;
        data["operator"] = this.operator;
        data["value"] = this.value;
        if (Array.isArray(this.specifications)) {
            data["specifications"] = [];
            for (let item of this.specifications)
                data["specifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISpecificationState {
    type: SpecificationStateType;
    property?: string | undefined;
    operator?: string | undefined;
    value?: string | undefined;
    specifications?: SpecificationState[] | undefined;
}

export class ProjectStateDto implements IProjectStateDto {
    id!: number;
    created?: Date | undefined;
    state!: ProjectState;
    projectTypeId!: number;
    architectId!: number;
    sku?: string | undefined;
    attributes?: any | undefined;
    mainImage?: ImageDto | undefined;
    images?: ImageDto[] | undefined;
    plans?: ImageDto[] | undefined;
    facades?: ImageDto[] | undefined;
    analogs?: ProjectAnalogStateDto[] | undefined;
    collections?: number[] | undefined;

    constructor(data?: IProjectStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.projectTypeId = _data["projectTypeId"];
            this.architectId = _data["architectId"];
            this.sku = _data["sku"];
            this.attributes = _data["attributes"];
            this.mainImage = _data["mainImage"] ? ImageDto.fromJS(_data["mainImage"]) : <any>undefined;
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ImageDto.fromJS(item));
            }
            if (Array.isArray(_data["plans"])) {
                this.plans = [] as any;
                for (let item of _data["plans"])
                    this.plans!.push(ImageDto.fromJS(item));
            }
            if (Array.isArray(_data["facades"])) {
                this.facades = [] as any;
                for (let item of _data["facades"])
                    this.facades!.push(ImageDto.fromJS(item));
            }
            if (Array.isArray(_data["analogs"])) {
                this.analogs = [] as any;
                for (let item of _data["analogs"])
                    this.analogs!.push(ProjectAnalogStateDto.fromJS(item));
            }
            if (Array.isArray(_data["collections"])) {
                this.collections = [] as any;
                for (let item of _data["collections"])
                    this.collections!.push(item);
            }
        }
    }

    static fromJS(data: any): ProjectStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["projectTypeId"] = this.projectTypeId;
        data["architectId"] = this.architectId;
        data["sku"] = this.sku;
        data["attributes"] = this.attributes;
        data["mainImage"] = this.mainImage ? this.mainImage.toJSON() : <any>undefined;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.plans)) {
            data["plans"] = [];
            for (let item of this.plans)
                data["plans"].push(item.toJSON());
        }
        if (Array.isArray(this.facades)) {
            data["facades"] = [];
            for (let item of this.facades)
                data["facades"].push(item.toJSON());
        }
        if (Array.isArray(this.analogs)) {
            data["analogs"] = [];
            for (let item of this.analogs)
                data["analogs"].push(item.toJSON());
        }
        if (Array.isArray(this.collections)) {
            data["collections"] = [];
            for (let item of this.collections)
                data["collections"].push(item);
        }
        return data; 
    }
}

export interface IProjectStateDto {
    id: number;
    created?: Date | undefined;
    state: ProjectState;
    projectTypeId: number;
    architectId: number;
    sku?: string | undefined;
    attributes?: any | undefined;
    mainImage?: ImageDto | undefined;
    images?: ImageDto[] | undefined;
    plans?: ImageDto[] | undefined;
    facades?: ImageDto[] | undefined;
    analogs?: ProjectAnalogStateDto[] | undefined;
    collections?: number[] | undefined;
}

export class ProjectAnalogStateDto implements IProjectAnalogStateDto {
    projectId!: number;
    comment?: string | undefined;

    constructor(data?: IProjectAnalogStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ProjectAnalogStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAnalogStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IProjectAnalogStateDto {
    projectId: number;
    comment?: string | undefined;
}

export class ProjectAnalogDto extends ProjectDto implements IProjectAnalogDto {
    comment?: string | undefined;

    constructor(data?: IProjectAnalogDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ProjectAnalogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAnalogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        super.toJSON(data);
        return data; 
    }
}

export interface IProjectAnalogDto extends IProjectDto {
    comment?: string | undefined;
}

export class ProjectBundleDto implements IProjectBundleDto {
    id!: number;
    name?: string | undefined;
    discount!: number;
    totalPrice?: number | undefined;

    constructor(data?: IProjectBundleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.discount = _data["discount"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): ProjectBundleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectBundleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["discount"] = this.discount;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IProjectBundleDto {
    id: number;
    name?: string | undefined;
    discount: number;
    totalPrice?: number | undefined;
}

export class ProjectBundleStateDto implements IProjectBundleStateDto {
    id?: number | undefined;
    name?: string | undefined;
    discount!: number;
    options?: ProjectBundleOptionStateDto[] | undefined;

    constructor(data?: IProjectBundleStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.discount = _data["discount"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(ProjectBundleOptionStateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectBundleStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectBundleStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["discount"] = this.discount;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProjectBundleStateDto {
    id?: number | undefined;
    name?: string | undefined;
    discount: number;
    options?: ProjectBundleOptionStateDto[] | undefined;
}

export class ProjectBundleOptionStateDto implements IProjectBundleOptionStateDto {
    optionId!: number;
    count!: number;
    price?: number | undefined;

    constructor(data?: IProjectBundleOptionStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.optionId = _data["optionId"];
            this.count = _data["count"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): ProjectBundleOptionStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectBundleOptionStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["optionId"] = this.optionId;
        data["count"] = this.count;
        data["price"] = this.price;
        return data; 
    }
}

export interface IProjectBundleOptionStateDto {
    optionId: number;
    count: number;
    price?: number | undefined;
}

export class ProjectBundlePricesDto implements IProjectBundlePricesDto {
    subTotal?: number | undefined;
    discount?: number | undefined;
    total?: number | undefined;
    options?: ProjectBundleOptionPriceDto[] | undefined;

    constructor(data?: IProjectBundlePricesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subTotal = _data["subTotal"];
            this.discount = _data["discount"];
            this.total = _data["total"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(ProjectBundleOptionPriceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectBundlePricesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectBundlePricesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subTotal"] = this.subTotal;
        data["discount"] = this.discount;
        data["total"] = this.total;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProjectBundlePricesDto {
    subTotal?: number | undefined;
    discount?: number | undefined;
    total?: number | undefined;
    options?: ProjectBundleOptionPriceDto[] | undefined;
}

export class ProjectBundleOptionPriceDto implements IProjectBundleOptionPriceDto {
    optionId!: number;
    price?: number | undefined;
    priceRecommended?: number | undefined;
    total?: number | undefined;

    constructor(data?: IProjectBundleOptionPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.optionId = _data["optionId"];
            this.price = _data["price"];
            this.priceRecommended = _data["priceRecommended"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ProjectBundleOptionPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectBundleOptionPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["optionId"] = this.optionId;
        data["price"] = this.price;
        data["priceRecommended"] = this.priceRecommended;
        data["total"] = this.total;
        return data; 
    }
}

export interface IProjectBundleOptionPriceDto {
    optionId: number;
    price?: number | undefined;
    priceRecommended?: number | undefined;
    total?: number | undefined;
}

export class ProjectChangeResultOfProjectBundleStateDto implements IProjectChangeResultOfProjectBundleStateDto {
    state!: ProjectState;
    price?: number | undefined;
    data?: ProjectBundleStateDto | undefined;

    constructor(data?: IProjectChangeResultOfProjectBundleStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.price = _data["price"];
            this.data = _data["data"] ? ProjectBundleStateDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectChangeResultOfProjectBundleStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectChangeResultOfProjectBundleStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["price"] = this.price;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProjectChangeResultOfProjectBundleStateDto {
    state: ProjectState;
    price?: number | undefined;
    data?: ProjectBundleStateDto | undefined;
}

export class CreateProjectCommandDto implements ICreateProjectCommandDto {
    projectTypeId!: number;
    architectId?: number | undefined;
    sku?: string | undefined;
    squareAll!: number;

    constructor(data?: ICreateProjectCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectTypeId = _data["projectTypeId"];
            this.architectId = _data["architectId"];
            this.sku = _data["sku"];
            this.squareAll = _data["squareAll"];
        }
    }

    static fromJS(data: any): CreateProjectCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectTypeId"] = this.projectTypeId;
        data["architectId"] = this.architectId;
        data["sku"] = this.sku;
        data["squareAll"] = this.squareAll;
        return data; 
    }
}

export interface ICreateProjectCommandDto {
    projectTypeId: number;
    architectId?: number | undefined;
    sku?: string | undefined;
    squareAll: number;
}

export class ValidationErrorResponseDto implements IValidationErrorResponseDto {
    errors?: ValidationErrorDto[] | undefined;

    constructor(data?: IValidationErrorResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationErrorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationErrorResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IValidationErrorResponseDto {
    errors?: ValidationErrorDto[] | undefined;
}

export class ValidationErrorDto implements IValidationErrorDto {
    fieldName?: string | undefined;
    message?: string | undefined;

    constructor(data?: IValidationErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ValidationErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["message"] = this.message;
        return data; 
    }
}

export interface IValidationErrorDto {
    fieldName?: string | undefined;
    message?: string | undefined;
}

export class ProjectTypeDto implements IProjectTypeDto {
    id!: number;
    name?: string | undefined;
    projectCode?: string | undefined;
    projectSeries!: number;

    constructor(data?: IProjectTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.projectCode = _data["projectCode"];
            this.projectSeries = _data["projectSeries"];
        }
    }

    static fromJS(data: any): ProjectTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["projectCode"] = this.projectCode;
        data["projectSeries"] = this.projectSeries;
        return data; 
    }
}

export interface IProjectTypeDto {
    id: number;
    name?: string | undefined;
    projectCode?: string | undefined;
    projectSeries: number;
}

export class ProjectTypeStateDto implements IProjectTypeStateDto {
    id?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    projectCode?: string | undefined;
    projectSeries!: number;
    groups?: PropertyGroupDto[] | undefined;
    properties?: PropertyDto[] | undefined;

    constructor(data?: IProjectTypeStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.projectCode = _data["projectCode"];
            this.projectSeries = _data["projectSeries"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(PropertyGroupDto.fromJS(item));
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(PropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectTypeStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["projectCode"] = this.projectCode;
        data["projectSeries"] = this.projectSeries;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProjectTypeStateDto {
    id?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    projectCode?: string | undefined;
    projectSeries: number;
    groups?: PropertyGroupDto[] | undefined;
    properties?: PropertyDto[] | undefined;
}

export class PropertyGroupDto implements IPropertyGroupDto {
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IPropertyGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PropertyGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPropertyGroupDto {
    code?: string | undefined;
    name?: string | undefined;
}

export class PropertyDto implements IPropertyDto {
    type?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    group?: string | undefined;
    editor?: string | undefined;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.group = _data["group"];
            this.editor = _data["editor"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["code"] = this.code;
        data["name"] = this.name;
        data["group"] = this.group;
        data["editor"] = this.editor;
        return data; 
    }
}

export interface IPropertyDto {
    type?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    group?: string | undefined;
    editor?: string | undefined;
}

export class PagedResultOfRedirectRuleDto implements IPagedResultOfRedirectRuleDto {
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    firstRowOnPage!: number;
    lastRowOnPage!: number;
    isLastPage!: boolean;
    items?: RedirectRuleDto[] | undefined;

    constructor(data?: IPagedResultOfRedirectRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
            this.isLastPage = _data["isLastPage"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RedirectRuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRedirectRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRedirectRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["isLastPage"] = this.isLastPage;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultOfRedirectRuleDto {
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    firstRowOnPage: number;
    lastRowOnPage: number;
    isLastPage: boolean;
    items?: RedirectRuleDto[] | undefined;
}

export class RedirectRuleDto implements IRedirectRuleDto {
    id?: number | undefined;
    oldSlug?: string | undefined;
    newSlug?: string | undefined;

    constructor(data?: IRedirectRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.oldSlug = _data["oldSlug"];
            this.newSlug = _data["newSlug"];
        }
    }

    static fromJS(data: any): RedirectRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RedirectRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["oldSlug"] = this.oldSlug;
        data["newSlug"] = this.newSlug;
        return data; 
    }
}

export interface IRedirectRuleDto {
    id?: number | undefined;
    oldSlug?: string | undefined;
    newSlug?: string | undefined;
}

export class RegionDto implements IRegionDto {
    id!: number;
    areaId!: number;
    area?: string | undefined;
    order!: number;
    name?: string | undefined;

    constructor(data?: IRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.areaId = _data["areaId"];
            this.area = _data["area"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["areaId"] = this.areaId;
        data["area"] = this.area;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRegionDto {
    id: number;
    areaId: number;
    area?: string | undefined;
    order: number;
    name?: string | undefined;
}

export class RegionStateDto implements IRegionStateDto {
    id?: number | undefined;
    areaId!: number;
    order!: number;
    name?: string | undefined;

    constructor(data?: IRegionStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.areaId = _data["areaId"];
            this.order = _data["order"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RegionStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["areaId"] = this.areaId;
        data["order"] = this.order;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRegionStateDto {
    id?: number | undefined;
    areaId: number;
    order: number;
    name?: string | undefined;
}

export class SettingDto implements ISettingDto {
    id!: number;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISettingDto {
    id: number;
    key?: string | undefined;
    value?: string | undefined;
}

export class SettingStateDto implements ISettingStateDto {
    id?: number | undefined;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISettingStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISettingStateDto {
    id?: number | undefined;
    key?: string | undefined;
    value?: string | undefined;
}

export class PagedResultOfUserDto implements IPagedResultOfUserDto {
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    firstRowOnPage!: number;
    lastRowOnPage!: number;
    isLastPage!: boolean;
    items?: UserDto[] | undefined;

    constructor(data?: IPagedResultOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
            this.isLastPage = _data["isLastPage"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["isLastPage"] = this.isLastPage;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultOfUserDto {
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    firstRowOnPage: number;
    lastRowOnPage: number;
    isLastPage: boolean;
    items?: UserDto[] | undefined;
}

export class UserStateDto implements IUserStateDto {
    id!: number;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    accessFailedCount!: number;
    lockoutEnabled!: boolean;
    lockoutEnd?: Date | undefined;
    roles?: string[] | undefined;

    constructor(data?: IUserStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["accessFailedCount"] = this.accessFailedCount;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IUserStateDto {
    id: number;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    accessFailedCount: number;
    lockoutEnabled: boolean;
    lockoutEnd?: Date | undefined;
    roles?: string[] | undefined;
}

export class CreateUserCommandResult implements ICreateUserCommandResult {
    userId!: number;
    password?: string | undefined;

    constructor(data?: ICreateUserCommandResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserCommandResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommandResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["password"] = this.password;
        return data; 
    }
}

export interface ICreateUserCommandResult {
    userId: number;
    password?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    userName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface ICreateUserCommand {
    userName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    roles?: string[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}